import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _objectSpread from "@babel/runtime/helpers/objectSpread";
import _extends from "@babel/runtime/helpers/extends";
import _css from "@emotion/css";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import { jsx as ___EmotionJSX } from "@emotion/core";
import React, { PureComponent } from 'react';
import Loadable from 'react-loadable';
import { gridSize as gridSizeFn } from '@atlaskit/theme/constants';
import { navigationItemClicked } from '../common/analytics';
import RenderBlocker from '../components/common/RenderBlocker';
import ContainerHeaderComponent from '../components/presentational/ContainerHeader';
import GroupComponent from '../components/presentational/Group';
import GroupHeadingComponent from '../components/presentational/GroupHeading';
import HeaderSectionComponent from '../components/presentational/HeaderSection';
import MenuSectionComponent from '../components/presentational/MenuSection';
import SectionComponent from '../components/presentational/Section';
import SectionHeadingComponent from '../components/presentational/SectionHeading';
import Separator from '../components/presentational/Separator';
import Wordmark from '../components/presentational/Wordmark';
import BackItem from '../components/connected/BackItem';
import ConnectedItem from '../components/connected/ConnectedItem';
import GoToItem from '../components/connected/GoToItem';
var gridSize = gridSizeFn();

var loadSwitcher = function loadSwitcher() {
  return import(
  /* webpackChunkName: "@atlaskit/navigation-next/async-chunk/switcher" */
  '../components/presentational/Switcher');
};

var LazySwitcher = Loadable({
  loader: loadSwitcher,
  loading: function loading() {
    return null;
  }
});

var loadSortableContextComponent = function loadSortableContextComponent() {
  return import(
  /* webpackChunkName: "@atlaskit/navigation-next/async-chunk/sortable-context-component" */
  '../components/connected/SortableContext');
};

var LazySortableContextComponent = Loadable({
  loader: loadSortableContextComponent,
  loading: function loading() {
    return null;
  }
});

var loadSortableGroupComponent = function loadSortableGroupComponent() {
  return import(
  /* webpackChunkName: "@atlaskit/navigation-next/async-chunk/sortable-group-component" */
  '../components/connected/SortableGroup');
};

export var LazySortableGroupComponent = Loadable({
  loader: loadSortableGroupComponent,
  loading: function loading() {
    return null;
  }
});

var loadSortableItem = function loadSortableItem() {
  return import(
  /* webpackChunkName: "@atlaskit/navigation-next/async-chunk/sortable-item" */
  '../components/connected/SortableItem');
};

export var LazySortableItem = Loadable({
  loader: loadSortableItem,
  loading: function loading() {
    return null;
  }
});
/**
 * ITEMS
 */
// Title

var GroupHeading = function GroupHeading(_ref) {
  var text = _ref.text,
      props = _objectWithoutProperties(_ref, ["text"]);

  return ___EmotionJSX(GroupHeadingComponent, props, text);
}; // SectionHeading


var SectionHeading = function SectionHeading(_ref2) {
  var text = _ref2.text,
      props = _objectWithoutProperties(_ref2, ["text"]);

  return ___EmotionJSX(SectionHeadingComponent, props, text);
}; // ContainerHeader


var ContainerHeader = function ContainerHeader(props) {
  return (// -2px here to account for the extra space at the top of a MenuSection for
    // the scroll hint.
    ___EmotionJSX("div", {
      css:
      /*#__PURE__*/
      _css({
        paddingBottom: gridSize * 2.5 - 2
      }, process.env.NODE_ENV === "production" ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yZW5kZXJlci9jb21wb25lbnRzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW9HTyIsImZpbGUiOiIuLi8uLi8uLi9zcmMvcmVuZGVyZXIvY29tcG9uZW50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5cbmltcG9ydCBSZWFjdCwge1xuICBQdXJlQ29tcG9uZW50LFxuICB0eXBlIENvbXBvbmVudFR5cGUsXG4gIHR5cGUgRWxlbWVudENvbmZpZyxcbiAgdHlwZSBOb2RlLFxufSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgTG9hZGFibGUgZnJvbSAncmVhY3QtbG9hZGFibGUnO1xuaW1wb3J0IHsgZ3JpZFNpemUgYXMgZ3JpZFNpemVGbiB9IGZyb20gJ0BhdGxhc2tpdC90aGVtZS9jb25zdGFudHMnO1xuXG5pbXBvcnQgeyBuYXZpZ2F0aW9uSXRlbUNsaWNrZWQgfSBmcm9tICcuLi9jb21tb24vYW5hbHl0aWNzJztcblxuaW1wb3J0IFJlbmRlckJsb2NrZXIgZnJvbSAnLi4vY29tcG9uZW50cy9jb21tb24vUmVuZGVyQmxvY2tlcic7XG5cbmltcG9ydCBDb250YWluZXJIZWFkZXJDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50cy9wcmVzZW50YXRpb25hbC9Db250YWluZXJIZWFkZXInO1xuaW1wb3J0IEdyb3VwQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudHMvcHJlc2VudGF0aW9uYWwvR3JvdXAnO1xuaW1wb3J0IEdyb3VwSGVhZGluZ0NvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnRzL3ByZXNlbnRhdGlvbmFsL0dyb3VwSGVhZGluZyc7XG5pbXBvcnQgSGVhZGVyU2VjdGlvbkNvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnRzL3ByZXNlbnRhdGlvbmFsL0hlYWRlclNlY3Rpb24nO1xuaW1wb3J0IE1lbnVTZWN0aW9uQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudHMvcHJlc2VudGF0aW9uYWwvTWVudVNlY3Rpb24nO1xuaW1wb3J0IFNlY3Rpb25Db21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50cy9wcmVzZW50YXRpb25hbC9TZWN0aW9uJztcbmltcG9ydCBTZWN0aW9uSGVhZGluZ0NvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnRzL3ByZXNlbnRhdGlvbmFsL1NlY3Rpb25IZWFkaW5nJztcbmltcG9ydCBTZXBhcmF0b3IgZnJvbSAnLi4vY29tcG9uZW50cy9wcmVzZW50YXRpb25hbC9TZXBhcmF0b3InO1xuaW1wb3J0IFdvcmRtYXJrIGZyb20gJy4uL2NvbXBvbmVudHMvcHJlc2VudGF0aW9uYWwvV29yZG1hcmsnO1xuXG5pbXBvcnQgQmFja0l0ZW0gZnJvbSAnLi4vY29tcG9uZW50cy9jb25uZWN0ZWQvQmFja0l0ZW0nO1xuaW1wb3J0IENvbm5lY3RlZEl0ZW0gZnJvbSAnLi4vY29tcG9uZW50cy9jb25uZWN0ZWQvQ29ubmVjdGVkSXRlbSc7XG5pbXBvcnQgR29Ub0l0ZW0gZnJvbSAnLi4vY29tcG9uZW50cy9jb25uZWN0ZWQvR29Ub0l0ZW0nO1xuXG5pbXBvcnQgdHlwZSB7XG4gIEN1c3RvbUNvbXBvbmVudHMsXG4gIEdyb3VwUHJvcHMsXG4gIEdyb3VwSGVhZGluZ1Byb3BzLFxuICBIZWFkZXJTZWN0aW9uUHJvcHMsXG4gIEl0ZW1zUmVuZGVyZXJQcm9wcyxcbiAgTWVudVNlY3Rpb25Qcm9wcyxcbiAgU2VjdGlvbkhlYWRpbmdQcm9wcyxcbiAgU2VjdGlvblByb3BzLFxuICBTb3J0YWJsZUNvbnRleHRQcm9wcyxcbiAgU29ydGFibGVHcm91cFByb3BzLFxuICBOYXZpZ2F0aW9uUmVuZGVyZXJJdGVtVHlwZSxcbiAgVHlwZVNoYXBlLFxufSBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgZ3JpZFNpemUgPSBncmlkU2l6ZUZuKCk7XG5jb25zdCBsb2FkU3dpdGNoZXIgPSAoKSA9PlxuICBpbXBvcnQoXG4gICAgLyogd2VicGFja0NodW5rTmFtZTogXCJAYXRsYXNraXQvbmF2aWdhdGlvbi1uZXh0L2FzeW5jLWNodW5rL3N3aXRjaGVyXCIgKi8gJy4uL2NvbXBvbmVudHMvcHJlc2VudGF0aW9uYWwvU3dpdGNoZXInXG4gICk7XG5jb25zdCBMYXp5U3dpdGNoZXIgPSBMb2FkYWJsZSh7XG4gIGxvYWRlcjogbG9hZFN3aXRjaGVyLFxuICBsb2FkaW5nOiAoKSA9PiBudWxsLFxufSk7XG5cbmNvbnN0IGxvYWRTb3J0YWJsZUNvbnRleHRDb21wb25lbnQgPSAoKSA9PlxuICBpbXBvcnQoXG4gICAgLyogd2VicGFja0NodW5rTmFtZTogXCJAYXRsYXNraXQvbmF2aWdhdGlvbi1uZXh0L2FzeW5jLWNodW5rL3NvcnRhYmxlLWNvbnRleHQtY29tcG9uZW50XCIgKi8gJy4uL2NvbXBvbmVudHMvY29ubmVjdGVkL1NvcnRhYmxlQ29udGV4dCdcbiAgKTtcbmNvbnN0IExhenlTb3J0YWJsZUNvbnRleHRDb21wb25lbnQgPSBMb2FkYWJsZSh7XG4gIGxvYWRlcjogbG9hZFNvcnRhYmxlQ29udGV4dENvbXBvbmVudCxcbiAgbG9hZGluZzogKCkgPT4gbnVsbCxcbn0pO1xuXG5jb25zdCBsb2FkU29ydGFibGVHcm91cENvbXBvbmVudCA9ICgpID0+XG4gIGltcG9ydChcbiAgICAvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcIkBhdGxhc2tpdC9uYXZpZ2F0aW9uLW5leHQvYXN5bmMtY2h1bmsvc29ydGFibGUtZ3JvdXAtY29tcG9uZW50XCIgKi8gJy4uL2NvbXBvbmVudHMvY29ubmVjdGVkL1NvcnRhYmxlR3JvdXAnXG4gICk7XG5leHBvcnQgY29uc3QgTGF6eVNvcnRhYmxlR3JvdXBDb21wb25lbnQgPSBMb2FkYWJsZSh7XG4gIGxvYWRlcjogbG9hZFNvcnRhYmxlR3JvdXBDb21wb25lbnQsXG4gIGxvYWRpbmc6ICgpID0+IG51bGwsXG59KTtcblxuY29uc3QgbG9hZFNvcnRhYmxlSXRlbSA9ICgpID0+XG4gIGltcG9ydChcbiAgICAvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcIkBhdGxhc2tpdC9uYXZpZ2F0aW9uLW5leHQvYXN5bmMtY2h1bmsvc29ydGFibGUtaXRlbVwiICovICcuLi9jb21wb25lbnRzL2Nvbm5lY3RlZC9Tb3J0YWJsZUl0ZW0nXG4gICk7XG5leHBvcnQgY29uc3QgTGF6eVNvcnRhYmxlSXRlbSA9IExvYWRhYmxlKHtcbiAgbG9hZGVyOiBsb2FkU29ydGFibGVJdGVtLFxuICBsb2FkaW5nOiAoKSA9PiBudWxsLFxufSk7XG4vKipcbiAqIElURU1TXG4gKi9cblxuLy8gVGl0bGVcbmNvbnN0IEdyb3VwSGVhZGluZyA9ICh7IHRleHQsIC4uLnByb3BzIH06IEdyb3VwSGVhZGluZ1Byb3BzKTogTm9kZSA9PiAoXG4gIDxHcm91cEhlYWRpbmdDb21wb25lbnQgey4uLnByb3BzfT57dGV4dH08L0dyb3VwSGVhZGluZ0NvbXBvbmVudD5cbik7XG5cbi8vIFNlY3Rpb25IZWFkaW5nXG5jb25zdCBTZWN0aW9uSGVhZGluZyA9ICh7IHRleHQsIC4uLnByb3BzIH06IFNlY3Rpb25IZWFkaW5nUHJvcHMpOiBOb2RlID0+IChcbiAgPFNlY3Rpb25IZWFkaW5nQ29tcG9uZW50IHsuLi5wcm9wc30+e3RleHR9PC9TZWN0aW9uSGVhZGluZ0NvbXBvbmVudD5cbik7XG5cbi8vIENvbnRhaW5lckhlYWRlclxuY29uc3QgQ29udGFpbmVySGVhZGVyID0gKFxuICBwcm9wczogRWxlbWVudENvbmZpZzx0eXBlb2YgQ29udGFpbmVySGVhZGVyQ29tcG9uZW50Pixcbik6IE5vZGUgPT4gKFxuICAvLyAtMnB4IGhlcmUgdG8gYWNjb3VudCBmb3IgdGhlIGV4dHJhIHNwYWNlIGF0IHRoZSB0b3Agb2YgYSBNZW51U2VjdGlvbiBmb3JcbiAgLy8gdGhlIHNjcm9sbCBoaW50LlxuICA8ZGl2IGNzcz17eyBwYWRkaW5nQm90dG9tOiBncmlkU2l6ZSAqIDIuNSAtIDIgfX0+XG4gICAgPENvbnRhaW5lckhlYWRlckNvbXBvbmVudCB7Li4ucHJvcHN9IC8+XG4gIDwvZGl2PlxuKTtcblxuY29uc3QgRGVidWcgPSAocHJvcHM6IGFueSkgPT4gKFxuICA8cHJlXG4gICAgY3NzPXt7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMSknLFxuICAgICAgZm9udFNpemU6ICcxMHB4JyxcbiAgICAgIG92ZXJmbG93WDogJ2F1dG8nLFxuICAgICAgcGFkZGluZzogYCR7Z3JpZFNpemUgLyAyfXB4YCxcbiAgICB9fVxuICA+XG4gICAge0pTT04uc3RyaW5naWZ5KHByb3BzLCBudWxsLCAyKX1cbiAgPC9wcmU+XG4pO1xuXG4vKipcbiAqIEdST1VQU1xuICovXG5cbi8vIEdyb3VwXG5jb25zdCBHcm91cCA9IDxUOiBUeXBlU2hhcGU+KHtcbiAgY3VzdG9tQ29tcG9uZW50cyxcbiAgaGFzU2VwYXJhdG9yLFxuICBoZWFkaW5nLFxuICBpdGVtcyxcbiAgaWQsXG59OiBHcm91cFByb3BzPFQ+KSA9PlxuICBpdGVtcy5sZW5ndGggPyAoXG4gICAgPEdyb3VwQ29tcG9uZW50IGhlYWRpbmc9e2hlYWRpbmd9IGhhc1NlcGFyYXRvcj17aGFzU2VwYXJhdG9yfSBpZD17aWR9PlxuICAgICAgPFR5cGVkSXRlbXNSZW5kZXJlciBpdGVtcz17aXRlbXN9IGN1c3RvbUNvbXBvbmVudHM9e2N1c3RvbUNvbXBvbmVudHN9IC8+XG4gICAgPC9Hcm91cENvbXBvbmVudD5cbiAgKSA6IG51bGw7XG5cbmNvbnN0IFNvcnRhYmxlR3JvdXAgPSA8VDogVHlwZVNoYXBlPih7XG4gIGN1c3RvbUNvbXBvbmVudHMsXG4gIGhhc1NlcGFyYXRvcixcbiAgaGVhZGluZyxcbiAgaXRlbXMsXG4gIGlkLFxufTogU29ydGFibGVHcm91cFByb3BzPFQ+KSA9PlxuICBpdGVtcyAmJiBpdGVtcy5sZW5ndGggPyAoXG4gICAgPExhenlTb3J0YWJsZUdyb3VwQ29tcG9uZW50XG4gICAgICBoZWFkaW5nPXtoZWFkaW5nfVxuICAgICAgaGFzU2VwYXJhdG9yPXtoYXNTZXBhcmF0b3J9XG4gICAgICBpZD17aWR9XG4gICAgPlxuICAgICAgPFJlbmRlckJsb2NrZXIgaXRlbXM9e2l0ZW1zfSBjdXN0b21Db21wb25lbnRzPXtjdXN0b21Db21wb25lbnRzfT5cbiAgICAgICAgPFR5cGVkSXRlbXNSZW5kZXJlciBpdGVtcz17aXRlbXN9IGN1c3RvbUNvbXBvbmVudHM9e2N1c3RvbUNvbXBvbmVudHN9IC8+XG4gICAgICA8L1JlbmRlckJsb2NrZXI+XG4gICAgPC9MYXp5U29ydGFibGVHcm91cENvbXBvbmVudD5cbiAgKSA6IG51bGw7XG5cbi8vIFNlY3Rpb25cbmNvbnN0IFNlY3Rpb24gPSA8VDogVHlwZVNoYXBlPih7XG4gIGFsd2F5c1Nob3dTY3JvbGxIaW50ID0gZmFsc2UsXG4gIGN1c3RvbUNvbXBvbmVudHMsXG4gIGlkLFxuICBpdGVtcyxcbiAgbmVzdGVkR3JvdXBLZXksXG4gIHBhcmVudElkLFxuICBzaG91bGRHcm93LFxufTogU2VjdGlvblByb3BzPFQ+KSA9PlxuICBpdGVtcy5sZW5ndGggPyAoXG4gICAgPFNlY3Rpb25Db21wb25lbnRcbiAgICAgIGFsd2F5c1Nob3dTY3JvbGxIaW50PXthbHdheXNTaG93U2Nyb2xsSGludH1cbiAgICAgIGlkPXtpZH1cbiAgICAgIGtleT17bmVzdGVkR3JvdXBLZXl9XG4gICAgICBwYXJlbnRJZD17cGFyZW50SWR9XG4gICAgICBzaG91bGRHcm93PXtzaG91bGRHcm93fVxuICAgID5cbiAgICAgIHsoeyBjbGFzc05hbWUgfSkgPT4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lfT5cbiAgICAgICAgICA8VHlwZWRJdGVtc1JlbmRlcmVyXG4gICAgICAgICAgICBpdGVtcz17aXRlbXN9XG4gICAgICAgICAgICBjdXN0b21Db21wb25lbnRzPXtjdXN0b21Db21wb25lbnRzfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICA8L1NlY3Rpb25Db21wb25lbnQ+XG4gICkgOiBudWxsO1xuXG5jb25zdCBIZWFkZXJTZWN0aW9uID0gPFQ6IFR5cGVTaGFwZT4oe1xuICBjdXN0b21Db21wb25lbnRzLFxuICBpZCxcbiAgaXRlbXMsXG4gIG5lc3RlZEdyb3VwS2V5LFxufTogSGVhZGVyU2VjdGlvblByb3BzPFQ+KSA9PlxuICBpdGVtcy5sZW5ndGggPyAoXG4gICAgPEhlYWRlclNlY3Rpb25Db21wb25lbnQgaWQ9e2lkfSBrZXk9e25lc3RlZEdyb3VwS2V5fT5cbiAgICAgIHsoeyBjbGFzc05hbWUgfSkgPT4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lfT5cbiAgICAgICAgICA8VHlwZWRJdGVtc1JlbmRlcmVyXG4gICAgICAgICAgICBpdGVtcz17aXRlbXN9XG4gICAgICAgICAgICBjdXN0b21Db21wb25lbnRzPXtjdXN0b21Db21wb25lbnRzfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICA8L0hlYWRlclNlY3Rpb25Db21wb25lbnQ+XG4gICkgOiBudWxsO1xuXG5jb25zdCBNZW51U2VjdGlvbiA9IDxUOiBUeXBlU2hhcGU+KHtcbiAgYWx3YXlzU2hvd1Njcm9sbEhpbnQsXG4gIGN1c3RvbUNvbXBvbmVudHMsXG4gIGlkLFxuICBpdGVtcyxcbiAgbmVzdGVkR3JvdXBLZXksXG4gIHBhcmVudElkLFxufTogTWVudVNlY3Rpb25Qcm9wczxUPikgPT4gKFxuICA8TWVudVNlY3Rpb25Db21wb25lbnRcbiAgICBhbHdheXNTaG93U2Nyb2xsSGludD17YWx3YXlzU2hvd1Njcm9sbEhpbnR9XG4gICAgaWQ9e2lkfVxuICAgIGtleT17bmVzdGVkR3JvdXBLZXl9XG4gICAgcGFyZW50SWQ9e3BhcmVudElkfVxuICA+XG4gICAgeyh7IGNsYXNzTmFtZSB9KSA9PiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lfT5cbiAgICAgICAgPFR5cGVkSXRlbXNSZW5kZXJlciBpdGVtcz17aXRlbXN9IGN1c3RvbUNvbXBvbmVudHM9e2N1c3RvbUNvbXBvbmVudHN9IC8+XG4gICAgICA8L2Rpdj5cbiAgICApfVxuICA8L01lbnVTZWN0aW9uQ29tcG9uZW50PlxuKTtcblxuY29uc3QgU29ydGFibGVDb250ZXh0ID0gPFQ6IFR5cGVTaGFwZT4oe1xuICBjdXN0b21Db21wb25lbnRzLFxuICBpZCxcbiAgaXRlbXMsXG4gIG9uRHJhZ1N0YXJ0LFxuICBvbkRyYWdVcGRhdGUsXG4gIG9uRHJhZ0VuZCxcbn06IFNvcnRhYmxlQ29udGV4dFByb3BzPFQ+KSA9PlxuICBpdGVtcyAmJiBpdGVtcy5sZW5ndGggPyAoXG4gICAgPExhenlTb3J0YWJsZUNvbnRleHRDb21wb25lbnRcbiAgICAgIGlkPXtpZH1cbiAgICAgIG9uRHJhZ1N0YXJ0PXtvbkRyYWdTdGFydH1cbiAgICAgIG9uRHJhZ1VwZGF0ZT17b25EcmFnVXBkYXRlfVxuICAgICAgb25EcmFnRW5kPXtvbkRyYWdFbmR9XG4gICAgPlxuICAgICAgPFR5cGVkSXRlbXNSZW5kZXJlciBpdGVtcz17aXRlbXN9IGN1c3RvbUNvbXBvbmVudHM9e2N1c3RvbUNvbXBvbmVudHN9IC8+XG4gICAgPC9MYXp5U29ydGFibGVDb250ZXh0Q29tcG9uZW50PlxuICApIDogbnVsbDtcblxuY29uc3QgaXRlbUNvbXBvbmVudHMgPSB7XG4gIEJhY2tJdGVtLFxuICBDb250YWluZXJIZWFkZXIsXG4gIERlYnVnLFxuICBHb1RvSXRlbSxcbiAgR3JvdXBIZWFkaW5nLFxuICBJdGVtOiBDb25uZWN0ZWRJdGVtLFxuICBTb3J0YWJsZUl0ZW06IExhenlTb3J0YWJsZUl0ZW0sXG4gIFNlY3Rpb25IZWFkaW5nLFxuICBTZXBhcmF0b3IsXG4gIFN3aXRjaGVyOiBMYXp5U3dpdGNoZXIsXG4gIFdvcmRtYXJrLFxufTtcblxuY29uc3QgcmVuZGVySXRlbUNvbXBvbmVudCA9IDxUOiBlbXB0eT4oXG4gIHByb3BzOiBOYXZpZ2F0aW9uUmVuZGVyZXJJdGVtVHlwZTxUPixcbiAga2V5OiBzdHJpbmcsXG4gIGluZGV4OiBudW1iZXIsXG4pID0+IHtcbiAgbGV0IGVsZW1lbnQgPSBudWxsO1xuICAvLyBXZSBuZWVkIGFuIGV4cGxpY2l0IGNvbmRpdGlvbmFsIGFnYWluc3QgZWFjaCB0eXBlIGZvciBmbG93IHR5cGUgcmVmaW5lbWVudCB0byB3b3JrXG4gIGlmIChwcm9wcy50eXBlID09PSAnQmFja0l0ZW0nKSB7XG4gICAgY29uc3QgeyB0eXBlLCAuLi5jb21wUHJvcHMgfSA9IHByb3BzO1xuICAgIGVsZW1lbnQgPSA8QmFja0l0ZW0ga2V5PXtrZXl9IHsuLi5jb21wUHJvcHN9IGluZGV4PXtpbmRleH0gLz47XG4gIH0gZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gJ0NvbnRhaW5lckhlYWRlcicpIHtcbiAgICBjb25zdCB7IHR5cGUsIC4uLmNvbXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgZWxlbWVudCA9IDxDb250YWluZXJIZWFkZXIga2V5PXtrZXl9IHsuLi5jb21wUHJvcHN9IC8+O1xuICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdEZWJ1ZycpIHtcbiAgICBjb25zdCB7IHR5cGUsIC4uLmNvbXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgZWxlbWVudCA9IDxEZWJ1ZyBrZXk9e2tleX0gey4uLmNvbXBQcm9wc30gLz47XG4gIH0gZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gJ0dvVG9JdGVtJykge1xuICAgIGNvbnN0IHsgdHlwZSwgLi4uY29tcFByb3BzIH0gPSBwcm9wcztcbiAgICBlbGVtZW50ID0gPEdvVG9JdGVtIGtleT17a2V5fSB7Li4uY29tcFByb3BzfSBpbmRleD17aW5kZXh9IC8+O1xuICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdJdGVtJykge1xuICAgIGNvbnN0IHsgdHlwZSwgLi4uY29tcFByb3BzIH0gPSBwcm9wcztcbiAgICBlbGVtZW50ID0gPENvbm5lY3RlZEl0ZW0ga2V5PXtrZXl9IHsuLi5jb21wUHJvcHN9IGluZGV4PXtpbmRleH0gLz47XG4gIH0gZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gJ1NvcnRhYmxlSXRlbScpIHtcbiAgICBjb25zdCB7IHR5cGUsIC4uLmNvbXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgZWxlbWVudCA9IDxMYXp5U29ydGFibGVJdGVtIGtleT17a2V5fSB7Li4uY29tcFByb3BzfSBpbmRleD17aW5kZXh9IC8+O1xuICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdTZWN0aW9uSGVhZGluZycpIHtcbiAgICBjb25zdCB7IHR5cGUsIGlkLCAuLi5jb21wUHJvcHMgfSA9IHByb3BzO1xuICAgIGVsZW1lbnQgPSA8U2VjdGlvbkhlYWRpbmcga2V5PXtrZXl9IHsuLi5jb21wUHJvcHN9IC8+O1xuICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdTZXBhcmF0b3InKSB7XG4gICAgY29uc3QgeyB0eXBlLCBpZCwgLi4uY29tcFByb3BzIH0gPSBwcm9wcztcbiAgICBlbGVtZW50ID0gPFNlcGFyYXRvciBrZXk9e2tleX0gey4uLmNvbXBQcm9wc30gLz47XG4gIH0gZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gJ1N3aXRjaGVyJykge1xuICAgIGNvbnN0IHsgdHlwZSwgLi4uY29tcFByb3BzIH0gPSBwcm9wcztcbiAgICBlbGVtZW50ID0gPExhenlTd2l0Y2hlciBrZXk9e2tleX0gey4uLmNvbXBQcm9wc30gLz47XG4gIH0gZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gJ1dvcmRtYXJrJykge1xuICAgIGNvbnN0IHsgdHlwZSwgaWQsIC4uLmNvbXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgZWxlbWVudCA9IDxXb3JkbWFyayBrZXk9e2tleX0gey4uLmNvbXBQcm9wc30gLz47XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbmNvbnN0IGdyb3VwQ29tcG9uZW50cyA9IHtcbiAgR3JvdXAsXG4gIEhlYWRlclNlY3Rpb24sXG4gIE1lbnVTZWN0aW9uLFxuICBTZWN0aW9uLFxuICBTb3J0YWJsZUNvbnRleHQsXG4gIFNvcnRhYmxlR3JvdXAsXG59O1xuXG5jb25zdCByZW5kZXJHcm91cENvbXBvbmVudCA9IDxUOiBlbXB0eT4oXG4gIHByb3BzOiBOYXZpZ2F0aW9uUmVuZGVyZXJJdGVtVHlwZTxUPixcbiAga2V5OiBzdHJpbmcsXG4gIGN1c3RvbUNvbXBvbmVudHM6IEN1c3RvbUNvbXBvbmVudHMsXG4pID0+IHtcbiAgbGV0IGVsZW1lbnQgPSBudWxsO1xuICAvLyBXZSBuZWVkIGFuIGV4cGxpY2l0IGNvbmRpdGlvbmFsIGFnYWluc3QgZWFjaCB0eXBlIGZvciBmbG93IHR5cGUgcmVmaW5lbWVudCB0byB3b3JrXG4gIGlmIChwcm9wcy50eXBlID09PSAnR3JvdXAnKSB7XG4gICAgY29uc3QgeyB0eXBlLCAuLi5jb21wUHJvcHMgfSA9IHByb3BzO1xuICAgIGVsZW1lbnQgPSAoXG4gICAgICA8R3JvdXAga2V5PXtrZXl9IHsuLi5jb21wUHJvcHN9IGN1c3RvbUNvbXBvbmVudHM9e2N1c3RvbUNvbXBvbmVudHN9IC8+XG4gICAgKTtcbiAgfSBlbHNlIGlmIChwcm9wcy50eXBlID09PSAnSGVhZGVyU2VjdGlvbicpIHtcbiAgICBjb25zdCB7IHR5cGUsIC4uLmNvbXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgZWxlbWVudCA9IChcbiAgICAgIDxIZWFkZXJTZWN0aW9uXG4gICAgICAgIGtleT17a2V5fVxuICAgICAgICB7Li4uY29tcFByb3BzfVxuICAgICAgICBjdXN0b21Db21wb25lbnRzPXtjdXN0b21Db21wb25lbnRzfVxuICAgICAgLz5cbiAgICApO1xuICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdNZW51U2VjdGlvbicpIHtcbiAgICBjb25zdCB7IHR5cGUsIC4uLmNvbXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgZWxlbWVudCA9IChcbiAgICAgIDxNZW51U2VjdGlvblxuICAgICAgICBrZXk9e2tleX1cbiAgICAgICAgey4uLmNvbXBQcm9wc31cbiAgICAgICAgY3VzdG9tQ29tcG9uZW50cz17Y3VzdG9tQ29tcG9uZW50c31cbiAgICAgIC8+XG4gICAgKTtcbiAgfSBlbHNlIGlmIChwcm9wcy50eXBlID09PSAnU2VjdGlvbicpIHtcbiAgICBjb25zdCB7IHR5cGUsIC4uLmNvbXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgZWxlbWVudCA9IChcbiAgICAgIDxTZWN0aW9uIGtleT17a2V5fSB7Li4uY29tcFByb3BzfSBjdXN0b21Db21wb25lbnRzPXtjdXN0b21Db21wb25lbnRzfSAvPlxuICAgICk7XG4gIH0gZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gJ1NvcnRhYmxlQ29udGV4dCcpIHtcbiAgICBjb25zdCB7IHR5cGUsIC4uLmNvbXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgZWxlbWVudCA9IChcbiAgICAgIDxTb3J0YWJsZUNvbnRleHRcbiAgICAgICAga2V5PXtrZXl9XG4gICAgICAgIHsuLi5jb21wUHJvcHN9XG4gICAgICAgIGN1c3RvbUNvbXBvbmVudHM9e2N1c3RvbUNvbXBvbmVudHN9XG4gICAgICAvPlxuICAgICk7XG4gIH0gZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gJ1NvcnRhYmxlR3JvdXAnKSB7XG4gICAgY29uc3QgeyB0eXBlLCAuLi5jb21wUHJvcHMgfSA9IHByb3BzO1xuICAgIGVsZW1lbnQgPSAoXG4gICAgICA8U29ydGFibGVHcm91cFxuICAgICAgICBrZXk9e2tleX1cbiAgICAgICAgey4uLmNvbXBQcm9wc31cbiAgICAgICAgY3VzdG9tQ29tcG9uZW50cz17Y3VzdG9tQ29tcG9uZW50c31cbiAgICAgIC8+XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLy8gRXhwb3J0ZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cbmV4cG9ydCBjb25zdCBjb21wb25lbnRzID0geyAuLi5pdGVtQ29tcG9uZW50cywgLi4uZ3JvdXBDb21wb25lbnRzIH07XG5cbi8qKlxuICogUkVOREVSRVJcbiAqL1xuY2xhc3MgVHlwZWRJdGVtc1JlbmRlcmVyPFQ6IFR5cGVTaGFwZSA9IGVtcHR5PiBleHRlbmRzIFB1cmVDb21wb25lbnQ8XG4gIEl0ZW1zUmVuZGVyZXJQcm9wczxUPixcbj4ge1xuICBjdXN0b21Db21wb25lbnRzV2l0aEFuYWx5dGljczogTWFwPFxuICAgIHN0cmluZyB8IENvbXBvbmVudFR5cGU8Kj4sXG4gICAgQ29tcG9uZW50VHlwZTwqPixcbiAgPiA9IG5ldyBNYXAoKTtcblxuICBnZXRDdXN0b21Db21wb25lbnQgPSAoY29tcG9uZW50OiBzdHJpbmcgfCBDb21wb25lbnRUeXBlPCo+KSA9PiB7XG4gICAgLy8gY2FjaGUgY3VzdG9tIGNvbXBvbmVudHMgd3JhcHBlZCB3aXRoIGFuYWx5dGljc1xuICAgIC8vIHRvIHByZXZlbnQgcmUtbW91bnRpbmcgb2YgY29tcG9uZW50IG9uIHJlLXJlbmRlclxuICAgIGNvbnN0IHsgY3VzdG9tQ29tcG9uZW50cyA9IHt9IH0gPSB0aGlzLnByb3BzO1xuICAgIGxldCBjYWNoZWRDb21wb25lbnQgPSB0aGlzLmN1c3RvbUNvbXBvbmVudHNXaXRoQW5hbHl0aWNzLmdldChjb21wb25lbnQpO1xuICAgIGlmICghY2FjaGVkQ29tcG9uZW50KSB7XG4gICAgICBjYWNoZWRDb21wb25lbnQgPVxuICAgICAgICB0eXBlb2YgY29tcG9uZW50ID09PSAnc3RyaW5nJ1xuICAgICAgICAgID8gbmF2aWdhdGlvbkl0ZW1DbGlja2VkKGN1c3RvbUNvbXBvbmVudHNbY29tcG9uZW50XSwgY29tcG9uZW50KVxuICAgICAgICAgIDogbmF2aWdhdGlvbkl0ZW1DbGlja2VkKFxuICAgICAgICAgICAgICBjb21wb25lbnQsXG4gICAgICAgICAgICAgIGNvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCAnaW5saW5lQ3VzdG9tQ29tcG9uZW50JyxcbiAgICAgICAgICAgICk7XG4gICAgICB0aGlzLmN1c3RvbUNvbXBvbmVudHNXaXRoQW5hbHl0aWNzLnNldChjb21wb25lbnQsIGNhY2hlZENvbXBvbmVudCk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRDb21wb25lbnQ7XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgY3VzdG9tQ29tcG9uZW50cyA9IHt9LCBpdGVtcyB9ID0gdGhpcy5wcm9wcztcblxuICAgIC8vIFdlIGNhbm5vdCBkZXN0cnVjdHVyZSBwcm9wcy50eXBlIG90aGVyd2lzZSBmbG93IHR5cGUgcmVmaW5tZW50IGRvZXMgbm90IHdvcmtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvNTI1OVxuICAgIHJldHVybiBpdGVtcy5tYXAoKHByb3BzLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3Qga2V5ID1cbiAgICAgICAgdHlwZW9mIHByb3BzLm5lc3RlZEdyb3VwS2V5ID09PSAnc3RyaW5nJ1xuICAgICAgICAgID8gcHJvcHMubmVzdGVkR3JvdXBLZXlcbiAgICAgICAgICA6IHByb3BzLmlkO1xuXG4gICAgICBpZiAocHJvcHMudHlwZSA9PT0gJ0lubGluZUNvbXBvbmVudCcpIHtcbiAgICAgICAgY29uc3QgeyB0eXBlLCBjb21wb25lbnQsIC4uLmNvbXBvbmVudFByb3BzIH0gPSBwcm9wcztcbiAgICAgICAgLy8gSWYgdGhleSd2ZSBwcm92aWRlZCBhIGNvbXBvbmVudCBhcyB0aGUgdHlwZVxuICAgICAgICBjb25zdCBDdXN0b21Db21wb25lbnQgPSB0aGlzLmdldEN1c3RvbUNvbXBvbmVudChwcm9wcy5jb21wb25lbnQpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIDxDdXN0b21Db21wb25lbnRcbiAgICAgICAgICAgIGtleT17a2V5fVxuICAgICAgICAgICAgey4uLmNvbXBvbmVudFByb3BzfVxuICAgICAgICAgICAgaW5kZXg9e2luZGV4fVxuICAgICAgICAgICAgLy8gV2UgcGFzcyBvdXIgaW4tYnVpbHQgY29tcG9uZW50cyB0aHJvdWdoIHRvIGN1c3RvbSBjb21wb25lbnRzIHNvXG4gICAgICAgICAgICAvLyB0aGV5IGNhbiB3cmFwL3JlbmRlciB0aGVtIGlmIHRoZXkgd2FudCB0by5cbiAgICAgICAgICAgIGNvbXBvbmVudHM9e2NvbXBvbmVudHN9XG4gICAgICAgICAgICBjdXN0b21Db21wb25lbnRzPXtjdXN0b21Db21wb25lbnRzfVxuICAgICAgICAgIC8+XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LmtleXMoZ3JvdXBDb21wb25lbnRzKS5pbmNsdWRlcyhwcm9wcy50eXBlKSkge1xuICAgICAgICAvLyBJZiB0aGV5J3ZlIHByb3ZpZGVkIGEgdHlwZSB3aGljaCBtYXRjaGVzIG9uZSBvZiBvdXIgaW4tYnVpbHQgZ3JvdXBcbiAgICAgICAgLy8gY29tcG9uZW50c1xuICAgICAgICByZXR1cm4gcmVuZGVyR3JvdXBDb21wb25lbnQocHJvcHMsIGtleSwgY3VzdG9tQ29tcG9uZW50cyk7XG4gICAgICAgIC8vIElmIHRoZXkndmUgcHJvdmlkZWQgYSB0eXBlIHdoaWNoIG1hdGNoZXMgb25lIG9mIG91ciBpbi1idWlsdCBpdGVtXG4gICAgICAgIC8vIGNvbXBvbmVudHMuXG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LmtleXMoaXRlbUNvbXBvbmVudHMpLmluY2x1ZGVzKHByb3BzLnR5cGUpKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJJdGVtQ29tcG9uZW50KHByb3BzLCBrZXksIGluZGV4KTtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3Qua2V5cyhjdXN0b21Db21wb25lbnRzKS5pbmNsdWRlcyhwcm9wcy50eXBlKSkge1xuICAgICAgICBjb25zdCB7IHR5cGUsIC4uLmNvbXBvbmVudFByb3BzIH0gPSBwcm9wcztcbiAgICAgICAgLy8gSWYgdGhleSd2ZSBwcm92aWRlZCBhIHR5cGUgd2hpY2ggbWF0Y2hlcyBvbmUgb2YgdGhlaXIgZGVmaW5lZCBjdXN0b21cbiAgICAgICAgLy8gY29tcG9uZW50cy5cbiAgICAgICAgY29uc3QgQ3VzdG9tQ29tcG9uZW50ID0gdGhpcy5nZXRDdXN0b21Db21wb25lbnQodHlwZSk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPEN1c3RvbUNvbXBvbmVudFxuICAgICAgICAgICAga2V5PXtrZXl9XG4gICAgICAgICAgICB7Li4uY29tcG9uZW50UHJvcHN9XG4gICAgICAgICAgICBpbmRleD17aW5kZXh9XG4gICAgICAgICAgICAvLyBXZSBwYXNzIG91ciBpbi1idWlsdCBjb21wb25lbnRzIHRocm91Z2ggdG8gY3VzdG9tIGNvbXBvbmVudHMgc29cbiAgICAgICAgICAgIC8vIHRoZXkgY2FuIHdyYXAvcmVuZGVyIHRoZW0gaWYgdGhleSB3YW50IHRvLlxuICAgICAgICAgICAgY29tcG9uZW50cz17Y29tcG9uZW50c31cbiAgICAgICAgICAgIGN1c3RvbUNvbXBvbmVudHM9e2N1c3RvbUNvbXBvbmVudHN9XG4gICAgICAgICAgLz5cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDxEZWJ1ZyBrZXk9e2tleX0gdHlwZT17cHJvcHMudHlwZX0gey4uLnByb3BzfSAvPjtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUeXBlZEl0ZW1zUmVuZGVyZXI7XG4iXX0= */")
    }, ___EmotionJSX(ContainerHeaderComponent, props))
  );
};

var Debug = function Debug(props) {
  return ___EmotionJSX("pre", {
    css:
    /*#__PURE__*/
    _css({
      backgroundColor: 'rgba(0, 0, 0, 0.1)',
      fontSize: '10px',
      overflowX: 'auto',
      padding: "".concat(gridSize / 2, "px")
    }, process.env.NODE_ENV === "production" ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yZW5kZXJlci9jb21wb25lbnRzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTJHSSIsImZpbGUiOiIuLi8uLi8uLi9zcmMvcmVuZGVyZXIvY29tcG9uZW50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5cbmltcG9ydCBSZWFjdCwge1xuICBQdXJlQ29tcG9uZW50LFxuICB0eXBlIENvbXBvbmVudFR5cGUsXG4gIHR5cGUgRWxlbWVudENvbmZpZyxcbiAgdHlwZSBOb2RlLFxufSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgTG9hZGFibGUgZnJvbSAncmVhY3QtbG9hZGFibGUnO1xuaW1wb3J0IHsgZ3JpZFNpemUgYXMgZ3JpZFNpemVGbiB9IGZyb20gJ0BhdGxhc2tpdC90aGVtZS9jb25zdGFudHMnO1xuXG5pbXBvcnQgeyBuYXZpZ2F0aW9uSXRlbUNsaWNrZWQgfSBmcm9tICcuLi9jb21tb24vYW5hbHl0aWNzJztcblxuaW1wb3J0IFJlbmRlckJsb2NrZXIgZnJvbSAnLi4vY29tcG9uZW50cy9jb21tb24vUmVuZGVyQmxvY2tlcic7XG5cbmltcG9ydCBDb250YWluZXJIZWFkZXJDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50cy9wcmVzZW50YXRpb25hbC9Db250YWluZXJIZWFkZXInO1xuaW1wb3J0IEdyb3VwQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudHMvcHJlc2VudGF0aW9uYWwvR3JvdXAnO1xuaW1wb3J0IEdyb3VwSGVhZGluZ0NvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnRzL3ByZXNlbnRhdGlvbmFsL0dyb3VwSGVhZGluZyc7XG5pbXBvcnQgSGVhZGVyU2VjdGlvbkNvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnRzL3ByZXNlbnRhdGlvbmFsL0hlYWRlclNlY3Rpb24nO1xuaW1wb3J0IE1lbnVTZWN0aW9uQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudHMvcHJlc2VudGF0aW9uYWwvTWVudVNlY3Rpb24nO1xuaW1wb3J0IFNlY3Rpb25Db21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50cy9wcmVzZW50YXRpb25hbC9TZWN0aW9uJztcbmltcG9ydCBTZWN0aW9uSGVhZGluZ0NvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnRzL3ByZXNlbnRhdGlvbmFsL1NlY3Rpb25IZWFkaW5nJztcbmltcG9ydCBTZXBhcmF0b3IgZnJvbSAnLi4vY29tcG9uZW50cy9wcmVzZW50YXRpb25hbC9TZXBhcmF0b3InO1xuaW1wb3J0IFdvcmRtYXJrIGZyb20gJy4uL2NvbXBvbmVudHMvcHJlc2VudGF0aW9uYWwvV29yZG1hcmsnO1xuXG5pbXBvcnQgQmFja0l0ZW0gZnJvbSAnLi4vY29tcG9uZW50cy9jb25uZWN0ZWQvQmFja0l0ZW0nO1xuaW1wb3J0IENvbm5lY3RlZEl0ZW0gZnJvbSAnLi4vY29tcG9uZW50cy9jb25uZWN0ZWQvQ29ubmVjdGVkSXRlbSc7XG5pbXBvcnQgR29Ub0l0ZW0gZnJvbSAnLi4vY29tcG9uZW50cy9jb25uZWN0ZWQvR29Ub0l0ZW0nO1xuXG5pbXBvcnQgdHlwZSB7XG4gIEN1c3RvbUNvbXBvbmVudHMsXG4gIEdyb3VwUHJvcHMsXG4gIEdyb3VwSGVhZGluZ1Byb3BzLFxuICBIZWFkZXJTZWN0aW9uUHJvcHMsXG4gIEl0ZW1zUmVuZGVyZXJQcm9wcyxcbiAgTWVudVNlY3Rpb25Qcm9wcyxcbiAgU2VjdGlvbkhlYWRpbmdQcm9wcyxcbiAgU2VjdGlvblByb3BzLFxuICBTb3J0YWJsZUNvbnRleHRQcm9wcyxcbiAgU29ydGFibGVHcm91cFByb3BzLFxuICBOYXZpZ2F0aW9uUmVuZGVyZXJJdGVtVHlwZSxcbiAgVHlwZVNoYXBlLFxufSBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgZ3JpZFNpemUgPSBncmlkU2l6ZUZuKCk7XG5jb25zdCBsb2FkU3dpdGNoZXIgPSAoKSA9PlxuICBpbXBvcnQoXG4gICAgLyogd2VicGFja0NodW5rTmFtZTogXCJAYXRsYXNraXQvbmF2aWdhdGlvbi1uZXh0L2FzeW5jLWNodW5rL3N3aXRjaGVyXCIgKi8gJy4uL2NvbXBvbmVudHMvcHJlc2VudGF0aW9uYWwvU3dpdGNoZXInXG4gICk7XG5jb25zdCBMYXp5U3dpdGNoZXIgPSBMb2FkYWJsZSh7XG4gIGxvYWRlcjogbG9hZFN3aXRjaGVyLFxuICBsb2FkaW5nOiAoKSA9PiBudWxsLFxufSk7XG5cbmNvbnN0IGxvYWRTb3J0YWJsZUNvbnRleHRDb21wb25lbnQgPSAoKSA9PlxuICBpbXBvcnQoXG4gICAgLyogd2VicGFja0NodW5rTmFtZTogXCJAYXRsYXNraXQvbmF2aWdhdGlvbi1uZXh0L2FzeW5jLWNodW5rL3NvcnRhYmxlLWNvbnRleHQtY29tcG9uZW50XCIgKi8gJy4uL2NvbXBvbmVudHMvY29ubmVjdGVkL1NvcnRhYmxlQ29udGV4dCdcbiAgKTtcbmNvbnN0IExhenlTb3J0YWJsZUNvbnRleHRDb21wb25lbnQgPSBMb2FkYWJsZSh7XG4gIGxvYWRlcjogbG9hZFNvcnRhYmxlQ29udGV4dENvbXBvbmVudCxcbiAgbG9hZGluZzogKCkgPT4gbnVsbCxcbn0pO1xuXG5jb25zdCBsb2FkU29ydGFibGVHcm91cENvbXBvbmVudCA9ICgpID0+XG4gIGltcG9ydChcbiAgICAvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcIkBhdGxhc2tpdC9uYXZpZ2F0aW9uLW5leHQvYXN5bmMtY2h1bmsvc29ydGFibGUtZ3JvdXAtY29tcG9uZW50XCIgKi8gJy4uL2NvbXBvbmVudHMvY29ubmVjdGVkL1NvcnRhYmxlR3JvdXAnXG4gICk7XG5leHBvcnQgY29uc3QgTGF6eVNvcnRhYmxlR3JvdXBDb21wb25lbnQgPSBMb2FkYWJsZSh7XG4gIGxvYWRlcjogbG9hZFNvcnRhYmxlR3JvdXBDb21wb25lbnQsXG4gIGxvYWRpbmc6ICgpID0+IG51bGwsXG59KTtcblxuY29uc3QgbG9hZFNvcnRhYmxlSXRlbSA9ICgpID0+XG4gIGltcG9ydChcbiAgICAvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcIkBhdGxhc2tpdC9uYXZpZ2F0aW9uLW5leHQvYXN5bmMtY2h1bmsvc29ydGFibGUtaXRlbVwiICovICcuLi9jb21wb25lbnRzL2Nvbm5lY3RlZC9Tb3J0YWJsZUl0ZW0nXG4gICk7XG5leHBvcnQgY29uc3QgTGF6eVNvcnRhYmxlSXRlbSA9IExvYWRhYmxlKHtcbiAgbG9hZGVyOiBsb2FkU29ydGFibGVJdGVtLFxuICBsb2FkaW5nOiAoKSA9PiBudWxsLFxufSk7XG4vKipcbiAqIElURU1TXG4gKi9cblxuLy8gVGl0bGVcbmNvbnN0IEdyb3VwSGVhZGluZyA9ICh7IHRleHQsIC4uLnByb3BzIH06IEdyb3VwSGVhZGluZ1Byb3BzKTogTm9kZSA9PiAoXG4gIDxHcm91cEhlYWRpbmdDb21wb25lbnQgey4uLnByb3BzfT57dGV4dH08L0dyb3VwSGVhZGluZ0NvbXBvbmVudD5cbik7XG5cbi8vIFNlY3Rpb25IZWFkaW5nXG5jb25zdCBTZWN0aW9uSGVhZGluZyA9ICh7IHRleHQsIC4uLnByb3BzIH06IFNlY3Rpb25IZWFkaW5nUHJvcHMpOiBOb2RlID0+IChcbiAgPFNlY3Rpb25IZWFkaW5nQ29tcG9uZW50IHsuLi5wcm9wc30+e3RleHR9PC9TZWN0aW9uSGVhZGluZ0NvbXBvbmVudD5cbik7XG5cbi8vIENvbnRhaW5lckhlYWRlclxuY29uc3QgQ29udGFpbmVySGVhZGVyID0gKFxuICBwcm9wczogRWxlbWVudENvbmZpZzx0eXBlb2YgQ29udGFpbmVySGVhZGVyQ29tcG9uZW50Pixcbik6IE5vZGUgPT4gKFxuICAvLyAtMnB4IGhlcmUgdG8gYWNjb3VudCBmb3IgdGhlIGV4dHJhIHNwYWNlIGF0IHRoZSB0b3Agb2YgYSBNZW51U2VjdGlvbiBmb3JcbiAgLy8gdGhlIHNjcm9sbCBoaW50LlxuICA8ZGl2IGNzcz17eyBwYWRkaW5nQm90dG9tOiBncmlkU2l6ZSAqIDIuNSAtIDIgfX0+XG4gICAgPENvbnRhaW5lckhlYWRlckNvbXBvbmVudCB7Li4ucHJvcHN9IC8+XG4gIDwvZGl2PlxuKTtcblxuY29uc3QgRGVidWcgPSAocHJvcHM6IGFueSkgPT4gKFxuICA8cHJlXG4gICAgY3NzPXt7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMSknLFxuICAgICAgZm9udFNpemU6ICcxMHB4JyxcbiAgICAgIG92ZXJmbG93WDogJ2F1dG8nLFxuICAgICAgcGFkZGluZzogYCR7Z3JpZFNpemUgLyAyfXB4YCxcbiAgICB9fVxuICA+XG4gICAge0pTT04uc3RyaW5naWZ5KHByb3BzLCBudWxsLCAyKX1cbiAgPC9wcmU+XG4pO1xuXG4vKipcbiAqIEdST1VQU1xuICovXG5cbi8vIEdyb3VwXG5jb25zdCBHcm91cCA9IDxUOiBUeXBlU2hhcGU+KHtcbiAgY3VzdG9tQ29tcG9uZW50cyxcbiAgaGFzU2VwYXJhdG9yLFxuICBoZWFkaW5nLFxuICBpdGVtcyxcbiAgaWQsXG59OiBHcm91cFByb3BzPFQ+KSA9PlxuICBpdGVtcy5sZW5ndGggPyAoXG4gICAgPEdyb3VwQ29tcG9uZW50IGhlYWRpbmc9e2hlYWRpbmd9IGhhc1NlcGFyYXRvcj17aGFzU2VwYXJhdG9yfSBpZD17aWR9PlxuICAgICAgPFR5cGVkSXRlbXNSZW5kZXJlciBpdGVtcz17aXRlbXN9IGN1c3RvbUNvbXBvbmVudHM9e2N1c3RvbUNvbXBvbmVudHN9IC8+XG4gICAgPC9Hcm91cENvbXBvbmVudD5cbiAgKSA6IG51bGw7XG5cbmNvbnN0IFNvcnRhYmxlR3JvdXAgPSA8VDogVHlwZVNoYXBlPih7XG4gIGN1c3RvbUNvbXBvbmVudHMsXG4gIGhhc1NlcGFyYXRvcixcbiAgaGVhZGluZyxcbiAgaXRlbXMsXG4gIGlkLFxufTogU29ydGFibGVHcm91cFByb3BzPFQ+KSA9PlxuICBpdGVtcyAmJiBpdGVtcy5sZW5ndGggPyAoXG4gICAgPExhenlTb3J0YWJsZUdyb3VwQ29tcG9uZW50XG4gICAgICBoZWFkaW5nPXtoZWFkaW5nfVxuICAgICAgaGFzU2VwYXJhdG9yPXtoYXNTZXBhcmF0b3J9XG4gICAgICBpZD17aWR9XG4gICAgPlxuICAgICAgPFJlbmRlckJsb2NrZXIgaXRlbXM9e2l0ZW1zfSBjdXN0b21Db21wb25lbnRzPXtjdXN0b21Db21wb25lbnRzfT5cbiAgICAgICAgPFR5cGVkSXRlbXNSZW5kZXJlciBpdGVtcz17aXRlbXN9IGN1c3RvbUNvbXBvbmVudHM9e2N1c3RvbUNvbXBvbmVudHN9IC8+XG4gICAgICA8L1JlbmRlckJsb2NrZXI+XG4gICAgPC9MYXp5U29ydGFibGVHcm91cENvbXBvbmVudD5cbiAgKSA6IG51bGw7XG5cbi8vIFNlY3Rpb25cbmNvbnN0IFNlY3Rpb24gPSA8VDogVHlwZVNoYXBlPih7XG4gIGFsd2F5c1Nob3dTY3JvbGxIaW50ID0gZmFsc2UsXG4gIGN1c3RvbUNvbXBvbmVudHMsXG4gIGlkLFxuICBpdGVtcyxcbiAgbmVzdGVkR3JvdXBLZXksXG4gIHBhcmVudElkLFxuICBzaG91bGRHcm93LFxufTogU2VjdGlvblByb3BzPFQ+KSA9PlxuICBpdGVtcy5sZW5ndGggPyAoXG4gICAgPFNlY3Rpb25Db21wb25lbnRcbiAgICAgIGFsd2F5c1Nob3dTY3JvbGxIaW50PXthbHdheXNTaG93U2Nyb2xsSGludH1cbiAgICAgIGlkPXtpZH1cbiAgICAgIGtleT17bmVzdGVkR3JvdXBLZXl9XG4gICAgICBwYXJlbnRJZD17cGFyZW50SWR9XG4gICAgICBzaG91bGRHcm93PXtzaG91bGRHcm93fVxuICAgID5cbiAgICAgIHsoeyBjbGFzc05hbWUgfSkgPT4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lfT5cbiAgICAgICAgICA8VHlwZWRJdGVtc1JlbmRlcmVyXG4gICAgICAgICAgICBpdGVtcz17aXRlbXN9XG4gICAgICAgICAgICBjdXN0b21Db21wb25lbnRzPXtjdXN0b21Db21wb25lbnRzfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICA8L1NlY3Rpb25Db21wb25lbnQ+XG4gICkgOiBudWxsO1xuXG5jb25zdCBIZWFkZXJTZWN0aW9uID0gPFQ6IFR5cGVTaGFwZT4oe1xuICBjdXN0b21Db21wb25lbnRzLFxuICBpZCxcbiAgaXRlbXMsXG4gIG5lc3RlZEdyb3VwS2V5LFxufTogSGVhZGVyU2VjdGlvblByb3BzPFQ+KSA9PlxuICBpdGVtcy5sZW5ndGggPyAoXG4gICAgPEhlYWRlclNlY3Rpb25Db21wb25lbnQgaWQ9e2lkfSBrZXk9e25lc3RlZEdyb3VwS2V5fT5cbiAgICAgIHsoeyBjbGFzc05hbWUgfSkgPT4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lfT5cbiAgICAgICAgICA8VHlwZWRJdGVtc1JlbmRlcmVyXG4gICAgICAgICAgICBpdGVtcz17aXRlbXN9XG4gICAgICAgICAgICBjdXN0b21Db21wb25lbnRzPXtjdXN0b21Db21wb25lbnRzfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICA8L0hlYWRlclNlY3Rpb25Db21wb25lbnQ+XG4gICkgOiBudWxsO1xuXG5jb25zdCBNZW51U2VjdGlvbiA9IDxUOiBUeXBlU2hhcGU+KHtcbiAgYWx3YXlzU2hvd1Njcm9sbEhpbnQsXG4gIGN1c3RvbUNvbXBvbmVudHMsXG4gIGlkLFxuICBpdGVtcyxcbiAgbmVzdGVkR3JvdXBLZXksXG4gIHBhcmVudElkLFxufTogTWVudVNlY3Rpb25Qcm9wczxUPikgPT4gKFxuICA8TWVudVNlY3Rpb25Db21wb25lbnRcbiAgICBhbHdheXNTaG93U2Nyb2xsSGludD17YWx3YXlzU2hvd1Njcm9sbEhpbnR9XG4gICAgaWQ9e2lkfVxuICAgIGtleT17bmVzdGVkR3JvdXBLZXl9XG4gICAgcGFyZW50SWQ9e3BhcmVudElkfVxuICA+XG4gICAgeyh7IGNsYXNzTmFtZSB9KSA9PiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lfT5cbiAgICAgICAgPFR5cGVkSXRlbXNSZW5kZXJlciBpdGVtcz17aXRlbXN9IGN1c3RvbUNvbXBvbmVudHM9e2N1c3RvbUNvbXBvbmVudHN9IC8+XG4gICAgICA8L2Rpdj5cbiAgICApfVxuICA8L01lbnVTZWN0aW9uQ29tcG9uZW50PlxuKTtcblxuY29uc3QgU29ydGFibGVDb250ZXh0ID0gPFQ6IFR5cGVTaGFwZT4oe1xuICBjdXN0b21Db21wb25lbnRzLFxuICBpZCxcbiAgaXRlbXMsXG4gIG9uRHJhZ1N0YXJ0LFxuICBvbkRyYWdVcGRhdGUsXG4gIG9uRHJhZ0VuZCxcbn06IFNvcnRhYmxlQ29udGV4dFByb3BzPFQ+KSA9PlxuICBpdGVtcyAmJiBpdGVtcy5sZW5ndGggPyAoXG4gICAgPExhenlTb3J0YWJsZUNvbnRleHRDb21wb25lbnRcbiAgICAgIGlkPXtpZH1cbiAgICAgIG9uRHJhZ1N0YXJ0PXtvbkRyYWdTdGFydH1cbiAgICAgIG9uRHJhZ1VwZGF0ZT17b25EcmFnVXBkYXRlfVxuICAgICAgb25EcmFnRW5kPXtvbkRyYWdFbmR9XG4gICAgPlxuICAgICAgPFR5cGVkSXRlbXNSZW5kZXJlciBpdGVtcz17aXRlbXN9IGN1c3RvbUNvbXBvbmVudHM9e2N1c3RvbUNvbXBvbmVudHN9IC8+XG4gICAgPC9MYXp5U29ydGFibGVDb250ZXh0Q29tcG9uZW50PlxuICApIDogbnVsbDtcblxuY29uc3QgaXRlbUNvbXBvbmVudHMgPSB7XG4gIEJhY2tJdGVtLFxuICBDb250YWluZXJIZWFkZXIsXG4gIERlYnVnLFxuICBHb1RvSXRlbSxcbiAgR3JvdXBIZWFkaW5nLFxuICBJdGVtOiBDb25uZWN0ZWRJdGVtLFxuICBTb3J0YWJsZUl0ZW06IExhenlTb3J0YWJsZUl0ZW0sXG4gIFNlY3Rpb25IZWFkaW5nLFxuICBTZXBhcmF0b3IsXG4gIFN3aXRjaGVyOiBMYXp5U3dpdGNoZXIsXG4gIFdvcmRtYXJrLFxufTtcblxuY29uc3QgcmVuZGVySXRlbUNvbXBvbmVudCA9IDxUOiBlbXB0eT4oXG4gIHByb3BzOiBOYXZpZ2F0aW9uUmVuZGVyZXJJdGVtVHlwZTxUPixcbiAga2V5OiBzdHJpbmcsXG4gIGluZGV4OiBudW1iZXIsXG4pID0+IHtcbiAgbGV0IGVsZW1lbnQgPSBudWxsO1xuICAvLyBXZSBuZWVkIGFuIGV4cGxpY2l0IGNvbmRpdGlvbmFsIGFnYWluc3QgZWFjaCB0eXBlIGZvciBmbG93IHR5cGUgcmVmaW5lbWVudCB0byB3b3JrXG4gIGlmIChwcm9wcy50eXBlID09PSAnQmFja0l0ZW0nKSB7XG4gICAgY29uc3QgeyB0eXBlLCAuLi5jb21wUHJvcHMgfSA9IHByb3BzO1xuICAgIGVsZW1lbnQgPSA8QmFja0l0ZW0ga2V5PXtrZXl9IHsuLi5jb21wUHJvcHN9IGluZGV4PXtpbmRleH0gLz47XG4gIH0gZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gJ0NvbnRhaW5lckhlYWRlcicpIHtcbiAgICBjb25zdCB7IHR5cGUsIC4uLmNvbXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgZWxlbWVudCA9IDxDb250YWluZXJIZWFkZXIga2V5PXtrZXl9IHsuLi5jb21wUHJvcHN9IC8+O1xuICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdEZWJ1ZycpIHtcbiAgICBjb25zdCB7IHR5cGUsIC4uLmNvbXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgZWxlbWVudCA9IDxEZWJ1ZyBrZXk9e2tleX0gey4uLmNvbXBQcm9wc30gLz47XG4gIH0gZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gJ0dvVG9JdGVtJykge1xuICAgIGNvbnN0IHsgdHlwZSwgLi4uY29tcFByb3BzIH0gPSBwcm9wcztcbiAgICBlbGVtZW50ID0gPEdvVG9JdGVtIGtleT17a2V5fSB7Li4uY29tcFByb3BzfSBpbmRleD17aW5kZXh9IC8+O1xuICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdJdGVtJykge1xuICAgIGNvbnN0IHsgdHlwZSwgLi4uY29tcFByb3BzIH0gPSBwcm9wcztcbiAgICBlbGVtZW50ID0gPENvbm5lY3RlZEl0ZW0ga2V5PXtrZXl9IHsuLi5jb21wUHJvcHN9IGluZGV4PXtpbmRleH0gLz47XG4gIH0gZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gJ1NvcnRhYmxlSXRlbScpIHtcbiAgICBjb25zdCB7IHR5cGUsIC4uLmNvbXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgZWxlbWVudCA9IDxMYXp5U29ydGFibGVJdGVtIGtleT17a2V5fSB7Li4uY29tcFByb3BzfSBpbmRleD17aW5kZXh9IC8+O1xuICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdTZWN0aW9uSGVhZGluZycpIHtcbiAgICBjb25zdCB7IHR5cGUsIGlkLCAuLi5jb21wUHJvcHMgfSA9IHByb3BzO1xuICAgIGVsZW1lbnQgPSA8U2VjdGlvbkhlYWRpbmcga2V5PXtrZXl9IHsuLi5jb21wUHJvcHN9IC8+O1xuICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdTZXBhcmF0b3InKSB7XG4gICAgY29uc3QgeyB0eXBlLCBpZCwgLi4uY29tcFByb3BzIH0gPSBwcm9wcztcbiAgICBlbGVtZW50ID0gPFNlcGFyYXRvciBrZXk9e2tleX0gey4uLmNvbXBQcm9wc30gLz47XG4gIH0gZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gJ1N3aXRjaGVyJykge1xuICAgIGNvbnN0IHsgdHlwZSwgLi4uY29tcFByb3BzIH0gPSBwcm9wcztcbiAgICBlbGVtZW50ID0gPExhenlTd2l0Y2hlciBrZXk9e2tleX0gey4uLmNvbXBQcm9wc30gLz47XG4gIH0gZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gJ1dvcmRtYXJrJykge1xuICAgIGNvbnN0IHsgdHlwZSwgaWQsIC4uLmNvbXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgZWxlbWVudCA9IDxXb3JkbWFyayBrZXk9e2tleX0gey4uLmNvbXBQcm9wc30gLz47XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbmNvbnN0IGdyb3VwQ29tcG9uZW50cyA9IHtcbiAgR3JvdXAsXG4gIEhlYWRlclNlY3Rpb24sXG4gIE1lbnVTZWN0aW9uLFxuICBTZWN0aW9uLFxuICBTb3J0YWJsZUNvbnRleHQsXG4gIFNvcnRhYmxlR3JvdXAsXG59O1xuXG5jb25zdCByZW5kZXJHcm91cENvbXBvbmVudCA9IDxUOiBlbXB0eT4oXG4gIHByb3BzOiBOYXZpZ2F0aW9uUmVuZGVyZXJJdGVtVHlwZTxUPixcbiAga2V5OiBzdHJpbmcsXG4gIGN1c3RvbUNvbXBvbmVudHM6IEN1c3RvbUNvbXBvbmVudHMsXG4pID0+IHtcbiAgbGV0IGVsZW1lbnQgPSBudWxsO1xuICAvLyBXZSBuZWVkIGFuIGV4cGxpY2l0IGNvbmRpdGlvbmFsIGFnYWluc3QgZWFjaCB0eXBlIGZvciBmbG93IHR5cGUgcmVmaW5lbWVudCB0byB3b3JrXG4gIGlmIChwcm9wcy50eXBlID09PSAnR3JvdXAnKSB7XG4gICAgY29uc3QgeyB0eXBlLCAuLi5jb21wUHJvcHMgfSA9IHByb3BzO1xuICAgIGVsZW1lbnQgPSAoXG4gICAgICA8R3JvdXAga2V5PXtrZXl9IHsuLi5jb21wUHJvcHN9IGN1c3RvbUNvbXBvbmVudHM9e2N1c3RvbUNvbXBvbmVudHN9IC8+XG4gICAgKTtcbiAgfSBlbHNlIGlmIChwcm9wcy50eXBlID09PSAnSGVhZGVyU2VjdGlvbicpIHtcbiAgICBjb25zdCB7IHR5cGUsIC4uLmNvbXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgZWxlbWVudCA9IChcbiAgICAgIDxIZWFkZXJTZWN0aW9uXG4gICAgICAgIGtleT17a2V5fVxuICAgICAgICB7Li4uY29tcFByb3BzfVxuICAgICAgICBjdXN0b21Db21wb25lbnRzPXtjdXN0b21Db21wb25lbnRzfVxuICAgICAgLz5cbiAgICApO1xuICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdNZW51U2VjdGlvbicpIHtcbiAgICBjb25zdCB7IHR5cGUsIC4uLmNvbXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgZWxlbWVudCA9IChcbiAgICAgIDxNZW51U2VjdGlvblxuICAgICAgICBrZXk9e2tleX1cbiAgICAgICAgey4uLmNvbXBQcm9wc31cbiAgICAgICAgY3VzdG9tQ29tcG9uZW50cz17Y3VzdG9tQ29tcG9uZW50c31cbiAgICAgIC8+XG4gICAgKTtcbiAgfSBlbHNlIGlmIChwcm9wcy50eXBlID09PSAnU2VjdGlvbicpIHtcbiAgICBjb25zdCB7IHR5cGUsIC4uLmNvbXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgZWxlbWVudCA9IChcbiAgICAgIDxTZWN0aW9uIGtleT17a2V5fSB7Li4uY29tcFByb3BzfSBjdXN0b21Db21wb25lbnRzPXtjdXN0b21Db21wb25lbnRzfSAvPlxuICAgICk7XG4gIH0gZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gJ1NvcnRhYmxlQ29udGV4dCcpIHtcbiAgICBjb25zdCB7IHR5cGUsIC4uLmNvbXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgZWxlbWVudCA9IChcbiAgICAgIDxTb3J0YWJsZUNvbnRleHRcbiAgICAgICAga2V5PXtrZXl9XG4gICAgICAgIHsuLi5jb21wUHJvcHN9XG4gICAgICAgIGN1c3RvbUNvbXBvbmVudHM9e2N1c3RvbUNvbXBvbmVudHN9XG4gICAgICAvPlxuICAgICk7XG4gIH0gZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gJ1NvcnRhYmxlR3JvdXAnKSB7XG4gICAgY29uc3QgeyB0eXBlLCAuLi5jb21wUHJvcHMgfSA9IHByb3BzO1xuICAgIGVsZW1lbnQgPSAoXG4gICAgICA8U29ydGFibGVHcm91cFxuICAgICAgICBrZXk9e2tleX1cbiAgICAgICAgey4uLmNvbXBQcm9wc31cbiAgICAgICAgY3VzdG9tQ29tcG9uZW50cz17Y3VzdG9tQ29tcG9uZW50c31cbiAgICAgIC8+XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLy8gRXhwb3J0ZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cbmV4cG9ydCBjb25zdCBjb21wb25lbnRzID0geyAuLi5pdGVtQ29tcG9uZW50cywgLi4uZ3JvdXBDb21wb25lbnRzIH07XG5cbi8qKlxuICogUkVOREVSRVJcbiAqL1xuY2xhc3MgVHlwZWRJdGVtc1JlbmRlcmVyPFQ6IFR5cGVTaGFwZSA9IGVtcHR5PiBleHRlbmRzIFB1cmVDb21wb25lbnQ8XG4gIEl0ZW1zUmVuZGVyZXJQcm9wczxUPixcbj4ge1xuICBjdXN0b21Db21wb25lbnRzV2l0aEFuYWx5dGljczogTWFwPFxuICAgIHN0cmluZyB8IENvbXBvbmVudFR5cGU8Kj4sXG4gICAgQ29tcG9uZW50VHlwZTwqPixcbiAgPiA9IG5ldyBNYXAoKTtcblxuICBnZXRDdXN0b21Db21wb25lbnQgPSAoY29tcG9uZW50OiBzdHJpbmcgfCBDb21wb25lbnRUeXBlPCo+KSA9PiB7XG4gICAgLy8gY2FjaGUgY3VzdG9tIGNvbXBvbmVudHMgd3JhcHBlZCB3aXRoIGFuYWx5dGljc1xuICAgIC8vIHRvIHByZXZlbnQgcmUtbW91bnRpbmcgb2YgY29tcG9uZW50IG9uIHJlLXJlbmRlclxuICAgIGNvbnN0IHsgY3VzdG9tQ29tcG9uZW50cyA9IHt9IH0gPSB0aGlzLnByb3BzO1xuICAgIGxldCBjYWNoZWRDb21wb25lbnQgPSB0aGlzLmN1c3RvbUNvbXBvbmVudHNXaXRoQW5hbHl0aWNzLmdldChjb21wb25lbnQpO1xuICAgIGlmICghY2FjaGVkQ29tcG9uZW50KSB7XG4gICAgICBjYWNoZWRDb21wb25lbnQgPVxuICAgICAgICB0eXBlb2YgY29tcG9uZW50ID09PSAnc3RyaW5nJ1xuICAgICAgICAgID8gbmF2aWdhdGlvbkl0ZW1DbGlja2VkKGN1c3RvbUNvbXBvbmVudHNbY29tcG9uZW50XSwgY29tcG9uZW50KVxuICAgICAgICAgIDogbmF2aWdhdGlvbkl0ZW1DbGlja2VkKFxuICAgICAgICAgICAgICBjb21wb25lbnQsXG4gICAgICAgICAgICAgIGNvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCAnaW5saW5lQ3VzdG9tQ29tcG9uZW50JyxcbiAgICAgICAgICAgICk7XG4gICAgICB0aGlzLmN1c3RvbUNvbXBvbmVudHNXaXRoQW5hbHl0aWNzLnNldChjb21wb25lbnQsIGNhY2hlZENvbXBvbmVudCk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRDb21wb25lbnQ7XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgY3VzdG9tQ29tcG9uZW50cyA9IHt9LCBpdGVtcyB9ID0gdGhpcy5wcm9wcztcblxuICAgIC8vIFdlIGNhbm5vdCBkZXN0cnVjdHVyZSBwcm9wcy50eXBlIG90aGVyd2lzZSBmbG93IHR5cGUgcmVmaW5tZW50IGRvZXMgbm90IHdvcmtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvNTI1OVxuICAgIHJldHVybiBpdGVtcy5tYXAoKHByb3BzLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3Qga2V5ID1cbiAgICAgICAgdHlwZW9mIHByb3BzLm5lc3RlZEdyb3VwS2V5ID09PSAnc3RyaW5nJ1xuICAgICAgICAgID8gcHJvcHMubmVzdGVkR3JvdXBLZXlcbiAgICAgICAgICA6IHByb3BzLmlkO1xuXG4gICAgICBpZiAocHJvcHMudHlwZSA9PT0gJ0lubGluZUNvbXBvbmVudCcpIHtcbiAgICAgICAgY29uc3QgeyB0eXBlLCBjb21wb25lbnQsIC4uLmNvbXBvbmVudFByb3BzIH0gPSBwcm9wcztcbiAgICAgICAgLy8gSWYgdGhleSd2ZSBwcm92aWRlZCBhIGNvbXBvbmVudCBhcyB0aGUgdHlwZVxuICAgICAgICBjb25zdCBDdXN0b21Db21wb25lbnQgPSB0aGlzLmdldEN1c3RvbUNvbXBvbmVudChwcm9wcy5jb21wb25lbnQpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIDxDdXN0b21Db21wb25lbnRcbiAgICAgICAgICAgIGtleT17a2V5fVxuICAgICAgICAgICAgey4uLmNvbXBvbmVudFByb3BzfVxuICAgICAgICAgICAgaW5kZXg9e2luZGV4fVxuICAgICAgICAgICAgLy8gV2UgcGFzcyBvdXIgaW4tYnVpbHQgY29tcG9uZW50cyB0aHJvdWdoIHRvIGN1c3RvbSBjb21wb25lbnRzIHNvXG4gICAgICAgICAgICAvLyB0aGV5IGNhbiB3cmFwL3JlbmRlciB0aGVtIGlmIHRoZXkgd2FudCB0by5cbiAgICAgICAgICAgIGNvbXBvbmVudHM9e2NvbXBvbmVudHN9XG4gICAgICAgICAgICBjdXN0b21Db21wb25lbnRzPXtjdXN0b21Db21wb25lbnRzfVxuICAgICAgICAgIC8+XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LmtleXMoZ3JvdXBDb21wb25lbnRzKS5pbmNsdWRlcyhwcm9wcy50eXBlKSkge1xuICAgICAgICAvLyBJZiB0aGV5J3ZlIHByb3ZpZGVkIGEgdHlwZSB3aGljaCBtYXRjaGVzIG9uZSBvZiBvdXIgaW4tYnVpbHQgZ3JvdXBcbiAgICAgICAgLy8gY29tcG9uZW50c1xuICAgICAgICByZXR1cm4gcmVuZGVyR3JvdXBDb21wb25lbnQocHJvcHMsIGtleSwgY3VzdG9tQ29tcG9uZW50cyk7XG4gICAgICAgIC8vIElmIHRoZXkndmUgcHJvdmlkZWQgYSB0eXBlIHdoaWNoIG1hdGNoZXMgb25lIG9mIG91ciBpbi1idWlsdCBpdGVtXG4gICAgICAgIC8vIGNvbXBvbmVudHMuXG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LmtleXMoaXRlbUNvbXBvbmVudHMpLmluY2x1ZGVzKHByb3BzLnR5cGUpKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJJdGVtQ29tcG9uZW50KHByb3BzLCBrZXksIGluZGV4KTtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3Qua2V5cyhjdXN0b21Db21wb25lbnRzKS5pbmNsdWRlcyhwcm9wcy50eXBlKSkge1xuICAgICAgICBjb25zdCB7IHR5cGUsIC4uLmNvbXBvbmVudFByb3BzIH0gPSBwcm9wcztcbiAgICAgICAgLy8gSWYgdGhleSd2ZSBwcm92aWRlZCBhIHR5cGUgd2hpY2ggbWF0Y2hlcyBvbmUgb2YgdGhlaXIgZGVmaW5lZCBjdXN0b21cbiAgICAgICAgLy8gY29tcG9uZW50cy5cbiAgICAgICAgY29uc3QgQ3VzdG9tQ29tcG9uZW50ID0gdGhpcy5nZXRDdXN0b21Db21wb25lbnQodHlwZSk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPEN1c3RvbUNvbXBvbmVudFxuICAgICAgICAgICAga2V5PXtrZXl9XG4gICAgICAgICAgICB7Li4uY29tcG9uZW50UHJvcHN9XG4gICAgICAgICAgICBpbmRleD17aW5kZXh9XG4gICAgICAgICAgICAvLyBXZSBwYXNzIG91ciBpbi1idWlsdCBjb21wb25lbnRzIHRocm91Z2ggdG8gY3VzdG9tIGNvbXBvbmVudHMgc29cbiAgICAgICAgICAgIC8vIHRoZXkgY2FuIHdyYXAvcmVuZGVyIHRoZW0gaWYgdGhleSB3YW50IHRvLlxuICAgICAgICAgICAgY29tcG9uZW50cz17Y29tcG9uZW50c31cbiAgICAgICAgICAgIGN1c3RvbUNvbXBvbmVudHM9e2N1c3RvbUNvbXBvbmVudHN9XG4gICAgICAgICAgLz5cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDxEZWJ1ZyBrZXk9e2tleX0gdHlwZT17cHJvcHMudHlwZX0gey4uLnByb3BzfSAvPjtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUeXBlZEl0ZW1zUmVuZGVyZXI7XG4iXX0= */")
  }, JSON.stringify(props, null, 2));
};
/**
 * GROUPS
 */
// Group


var Group = function Group(_ref3) {
  var customComponents = _ref3.customComponents,
      hasSeparator = _ref3.hasSeparator,
      heading = _ref3.heading,
      items = _ref3.items,
      id = _ref3.id;
  return items.length ? ___EmotionJSX(GroupComponent, {
    heading: heading,
    hasSeparator: hasSeparator,
    id: id
  }, ___EmotionJSX(TypedItemsRenderer, {
    items: items,
    customComponents: customComponents
  })) : null;
};

var SortableGroup = function SortableGroup(_ref4) {
  var customComponents = _ref4.customComponents,
      hasSeparator = _ref4.hasSeparator,
      heading = _ref4.heading,
      items = _ref4.items,
      id = _ref4.id;
  return items && items.length ? ___EmotionJSX(LazySortableGroupComponent, {
    heading: heading,
    hasSeparator: hasSeparator,
    id: id
  }, ___EmotionJSX(RenderBlocker, {
    items: items,
    customComponents: customComponents
  }, ___EmotionJSX(TypedItemsRenderer, {
    items: items,
    customComponents: customComponents
  }))) : null;
}; // Section


var Section = function Section(_ref5) {
  var _ref5$alwaysShowScrol = _ref5.alwaysShowScrollHint,
      alwaysShowScrollHint = _ref5$alwaysShowScrol === void 0 ? false : _ref5$alwaysShowScrol,
      customComponents = _ref5.customComponents,
      id = _ref5.id,
      items = _ref5.items,
      nestedGroupKey = _ref5.nestedGroupKey,
      parentId = _ref5.parentId,
      shouldGrow = _ref5.shouldGrow;
  return items.length ? ___EmotionJSX(SectionComponent, {
    alwaysShowScrollHint: alwaysShowScrollHint,
    id: id,
    key: nestedGroupKey,
    parentId: parentId,
    shouldGrow: shouldGrow
  }, function (_ref6) {
    var className = _ref6.className;
    return ___EmotionJSX("div", {
      className: className
    }, ___EmotionJSX(TypedItemsRenderer, {
      items: items,
      customComponents: customComponents
    }));
  }) : null;
};

var HeaderSection = function HeaderSection(_ref7) {
  var customComponents = _ref7.customComponents,
      id = _ref7.id,
      items = _ref7.items,
      nestedGroupKey = _ref7.nestedGroupKey;
  return items.length ? ___EmotionJSX(HeaderSectionComponent, {
    id: id,
    key: nestedGroupKey
  }, function (_ref8) {
    var className = _ref8.className;
    return ___EmotionJSX("div", {
      className: className
    }, ___EmotionJSX(TypedItemsRenderer, {
      items: items,
      customComponents: customComponents
    }));
  }) : null;
};

var MenuSection = function MenuSection(_ref9) {
  var alwaysShowScrollHint = _ref9.alwaysShowScrollHint,
      customComponents = _ref9.customComponents,
      id = _ref9.id,
      items = _ref9.items,
      nestedGroupKey = _ref9.nestedGroupKey,
      parentId = _ref9.parentId;
  return ___EmotionJSX(MenuSectionComponent, {
    alwaysShowScrollHint: alwaysShowScrollHint,
    id: id,
    key: nestedGroupKey,
    parentId: parentId
  }, function (_ref10) {
    var className = _ref10.className;
    return ___EmotionJSX("div", {
      className: className
    }, ___EmotionJSX(TypedItemsRenderer, {
      items: items,
      customComponents: customComponents
    }));
  });
};

var SortableContext = function SortableContext(_ref11) {
  var customComponents = _ref11.customComponents,
      id = _ref11.id,
      items = _ref11.items,
      onDragStart = _ref11.onDragStart,
      onDragUpdate = _ref11.onDragUpdate,
      onDragEnd = _ref11.onDragEnd;
  return items && items.length ? ___EmotionJSX(LazySortableContextComponent, {
    id: id,
    onDragStart: onDragStart,
    onDragUpdate: onDragUpdate,
    onDragEnd: onDragEnd
  }, ___EmotionJSX(TypedItemsRenderer, {
    items: items,
    customComponents: customComponents
  })) : null;
};

var itemComponents = {
  BackItem: BackItem,
  ContainerHeader: ContainerHeader,
  Debug: Debug,
  GoToItem: GoToItem,
  GroupHeading: GroupHeading,
  Item: ConnectedItem,
  SortableItem: LazySortableItem,
  SectionHeading: SectionHeading,
  Separator: Separator,
  Switcher: LazySwitcher,
  Wordmark: Wordmark
};

var renderItemComponent = function renderItemComponent(props, key, index) {
  var element = null; // We need an explicit conditional against each type for flow type refinement to work

  if (props.type === 'BackItem') {
    var type = props.type,
        compProps = _objectWithoutProperties(props, ["type"]);

    element = ___EmotionJSX(BackItem, _extends({
      key: key
    }, compProps, {
      index: index
    }));
  } else if (props.type === 'ContainerHeader') {
    var _type = props.type,
        _compProps = _objectWithoutProperties(props, ["type"]);

    element = ___EmotionJSX(ContainerHeader, _extends({
      key: key
    }, _compProps));
  } else if (props.type === 'Debug') {
    var _type2 = props.type,
        _compProps2 = _objectWithoutProperties(props, ["type"]);

    element = ___EmotionJSX(Debug, _extends({
      key: key
    }, _compProps2));
  } else if (props.type === 'GoToItem') {
    var _type3 = props.type,
        _compProps3 = _objectWithoutProperties(props, ["type"]);

    element = ___EmotionJSX(GoToItem, _extends({
      key: key
    }, _compProps3, {
      index: index
    }));
  } else if (props.type === 'Item') {
    var _type4 = props.type,
        _compProps4 = _objectWithoutProperties(props, ["type"]);

    element = ___EmotionJSX(ConnectedItem, _extends({
      key: key
    }, _compProps4, {
      index: index
    }));
  } else if (props.type === 'SortableItem') {
    var _type5 = props.type,
        _compProps5 = _objectWithoutProperties(props, ["type"]);

    element = ___EmotionJSX(LazySortableItem, _extends({
      key: key
    }, _compProps5, {
      index: index
    }));
  } else if (props.type === 'SectionHeading') {
    var _type6 = props.type,
        id = props.id,
        _compProps6 = _objectWithoutProperties(props, ["type", "id"]);

    element = ___EmotionJSX(SectionHeading, _extends({
      key: key
    }, _compProps6));
  } else if (props.type === 'Separator') {
    var _type7 = props.type,
        _id = props.id,
        _compProps7 = _objectWithoutProperties(props, ["type", "id"]);

    element = ___EmotionJSX(Separator, _extends({
      key: key
    }, _compProps7));
  } else if (props.type === 'Switcher') {
    var _type8 = props.type,
        _compProps8 = _objectWithoutProperties(props, ["type"]);

    element = ___EmotionJSX(LazySwitcher, _extends({
      key: key
    }, _compProps8));
  } else if (props.type === 'Wordmark') {
    var _type9 = props.type,
        _id2 = props.id,
        _compProps9 = _objectWithoutProperties(props, ["type", "id"]);

    element = ___EmotionJSX(Wordmark, _extends({
      key: key
    }, _compProps9));
  }

  return element;
};

var groupComponents = {
  Group: Group,
  HeaderSection: HeaderSection,
  MenuSection: MenuSection,
  Section: Section,
  SortableContext: SortableContext,
  SortableGroup: SortableGroup
};

var renderGroupComponent = function renderGroupComponent(props, key, customComponents) {
  var element = null; // We need an explicit conditional against each type for flow type refinement to work

  if (props.type === 'Group') {
    var type = props.type,
        compProps = _objectWithoutProperties(props, ["type"]);

    element = ___EmotionJSX(Group, _extends({
      key: key
    }, compProps, {
      customComponents: customComponents
    }));
  } else if (props.type === 'HeaderSection') {
    var _type10 = props.type,
        _compProps10 = _objectWithoutProperties(props, ["type"]);

    element = ___EmotionJSX(HeaderSection, _extends({
      key: key
    }, _compProps10, {
      customComponents: customComponents
    }));
  } else if (props.type === 'MenuSection') {
    var _type11 = props.type,
        _compProps11 = _objectWithoutProperties(props, ["type"]);

    element = ___EmotionJSX(MenuSection, _extends({
      key: key
    }, _compProps11, {
      customComponents: customComponents
    }));
  } else if (props.type === 'Section') {
    var _type12 = props.type,
        _compProps12 = _objectWithoutProperties(props, ["type"]);

    element = ___EmotionJSX(Section, _extends({
      key: key
    }, _compProps12, {
      customComponents: customComponents
    }));
  } else if (props.type === 'SortableContext') {
    var _type13 = props.type,
        _compProps13 = _objectWithoutProperties(props, ["type"]);

    element = ___EmotionJSX(SortableContext, _extends({
      key: key
    }, _compProps13, {
      customComponents: customComponents
    }));
  } else if (props.type === 'SortableGroup') {
    var _type14 = props.type,
        _compProps14 = _objectWithoutProperties(props, ["type"]);

    element = ___EmotionJSX(SortableGroup, _extends({
      key: key
    }, _compProps14, {
      customComponents: customComponents
    }));
  }

  return element;
}; // Exported for testing purposes only.


export var components = _objectSpread({}, itemComponents, groupComponents);
/**
 * RENDERER
 */

var TypedItemsRenderer =
/*#__PURE__*/
function (_PureComponent) {
  _inherits(TypedItemsRenderer, _PureComponent);

  function TypedItemsRenderer() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, TypedItemsRenderer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TypedItemsRenderer)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "customComponentsWithAnalytics", new Map());

    _defineProperty(_assertThisInitialized(_this), "getCustomComponent", function (component) {
      // cache custom components wrapped with analytics
      // to prevent re-mounting of component on re-render
      var _this$props$customCom = _this.props.customComponents,
          customComponents = _this$props$customCom === void 0 ? {} : _this$props$customCom;

      var cachedComponent = _this.customComponentsWithAnalytics.get(component);

      if (!cachedComponent) {
        cachedComponent = typeof component === 'string' ? navigationItemClicked(customComponents[component], component) : navigationItemClicked(component, component.displayName || 'inlineCustomComponent');

        _this.customComponentsWithAnalytics.set(component, cachedComponent);
      }

      return cachedComponent;
    });

    return _this;
  }

  _createClass(TypedItemsRenderer, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          _this$props$customCom2 = _this$props.customComponents,
          customComponents = _this$props$customCom2 === void 0 ? {} : _this$props$customCom2,
          items = _this$props.items; // We cannot destructure props.type otherwise flow type refinment does not work
      // https://github.com/facebook/flow/issues/5259

      return items.map(function (props, index) {
        var key = typeof props.nestedGroupKey === 'string' ? props.nestedGroupKey : props.id;

        if (props.type === 'InlineComponent') {
          var type = props.type,
              component = props.component,
              componentProps = _objectWithoutProperties(props, ["type", "component"]); // If they've provided a component as the type


          var CustomComponent = _this2.getCustomComponent(props.component);

          return ___EmotionJSX(CustomComponent, _extends({
            key: key
          }, componentProps, {
            index: index // We pass our in-built components through to custom components so
            // they can wrap/render them if they want to.
            ,
            components: components,
            customComponents: customComponents
          }));
        }

        if (Object.keys(groupComponents).includes(props.type)) {
          // If they've provided a type which matches one of our in-built group
          // components
          return renderGroupComponent(props, key, customComponents); // If they've provided a type which matches one of our in-built item
          // components.
        }

        if (Object.keys(itemComponents).includes(props.type)) {
          return renderItemComponent(props, key, index);
        }

        if (Object.keys(customComponents).includes(props.type)) {
          var _type15 = props.type,
              _componentProps = _objectWithoutProperties(props, ["type"]); // If they've provided a type which matches one of their defined custom
          // components.


          var _CustomComponent = _this2.getCustomComponent(_type15);

          return ___EmotionJSX(_CustomComponent, _extends({
            key: key
          }, _componentProps, {
            index: index // We pass our in-built components through to custom components so
            // they can wrap/render them if they want to.
            ,
            components: components,
            customComponents: customComponents
          }));
        }

        return ___EmotionJSX(Debug, _extends({
          key: key,
          type: props.type
        }, props));
      });
    }
  }]);

  return TypedItemsRenderer;
}(PureComponent);

export default TypedItemsRenderer;